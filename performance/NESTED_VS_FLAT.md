# 인덱스 구조별 쿼리 수용력 측정

---

## 한 줄 요약

**동일한 필터 요청이 들어왔을 때, 각 인덱스 구조가 감당할 수 있는 수준은 어디까지인가?**

### 결과 요약

|                    | LBT NoFM | LBT FM | L NoFM | L FM       |
|--------------------|----------|--------|--------|------------|
| **Lucene docs**    | ~87M     | ~87M   | ~39M   | ~39M       |
| **sequential avg** | 144ms    | 69ms   | 68ms   | **34ms**   |
| **sequential p50** | 98ms     | 48ms   | 42ms   | **14ms**   |
| **sequential p95** | 420ms    | 210ms  | 221ms  | **139ms**  |
| **25 users RPS**   | 6.46     | 13.94  | 10.75  | **27.32**  |
| **25 users p95**   | 4543ms   | 2588ms | 3694ms | **1381ms** |

> LBT는 forcemerge를 해야 L의 기본 상태(NoFM)를 겨우 따라잡는 수준 (69ms vs 68ms)

---

## 목적

두 인덱스 구조 선택지가 있다. 각각의 장단점이 다르다.
이 문서는 **각 선택지가 실제 쿼리를 얼마나 감당할 수 있는지** 수치로 보여주기 위한 기초 자료다.

- 어떤 구조가 "더 좋다"를 판단하는 것이 아님
- 각 구조에 동일한 필터 요청을 보냈을 때 **응답 속도와 처리량이 어느 선**인지를 측정
- 특히 LBT 구조는 시간에 따라 데이터가 누적되므로, **현재 기준에서도 감당 가능한지** 확인 필요
- 만약 현재 기준에서 이미 느리다면, 향후 구조 개선에 리소스가 필요하다는 근거

---

## 선택지

### 선택지 A: LBT — 토지 + 건물 배열 + 실거래 배열

> **"한 필지에 딸린 건물과 실거래 이력을 전부 담는다"**

| 항목 | 내용 |
|------|------|
| 인덱스 | `lbt_4x4_nofm_*` (4개 × 4샤드) |
| 문서 구조 | 토지 1 + `buildings[]` (nested N건) + `trades[]` (nested N건) |
| Lucene docs | **~87M** (필지 39M + 건물 6M + 실거래 41M이 각각 별도 Lucene doc) |
| 쿼리 방식 | 건물/실거래 필터 시 `nested` 쿼리 사용 |
| 장점 | 한 필지의 모든 건물/거래 이력 검색 가능. 데이터 완결성 높음 |
| 단점 | nested doc이 Lucene doc 수를 2배 이상 부풀림. 데이터 쌓일수록 악화 |
| 시간에 따른 변화 | 실거래가 매년 쌓임 → **Lucene docs 지속 증가 → 성능 점진 저하** |

```
현재:  필지 39M + 건물 6M + 실거래 41M  = 87M Lucene docs
1년후: 필지 39M + 건물 6M + 실거래 50M+ = 95M+
3년후: 필지 39M + 건물 7M + 실거래 70M+ = 116M+
```

### 선택지 B: L — 토지 + 건물 1건 + 실거래 1건

> **"한 필지에 대표 건물 1건과 최신 실거래 1건만 담는다"**

| 항목 | 내용 |
|------|------|
| 인덱스 | `l_4x4_nofm_*` (4개 × 4샤드) |
| 문서 구조 | 토지 1 + `building` (object 1건) + `trade` (object 1건) |
| Lucene docs | **~39M** (필지당 정확히 1 Lucene doc) |
| 쿼리 방식 | 모든 필터가 root-level (nested 불필요) |
| 장점 | 단순한 구조. Lucene doc 수 고정. 예측 가능한 성능 |
| 단점 | 건물/실거래 이력 검색 불가. 대표 1건만으로 필터링 |
| 시간에 따른 변화 | 필지 수가 크게 변하지 않는 한 **Lucene docs 거의 고정** |

```
현재:  39M Lucene docs
1년후: 39M Lucene docs
3년후: 39M Lucene docs
```

### 나열 — 동일 환경

두 선택지 모두 아래 조건에서 측정:

| 항목 | 값 |
|------|-----|
| OpenSearch | 2.11.1 |
| 노드 | 단일 노드 (Docker) |
| 리소스 | CPU 3코어, 메모리 4GB heap / 8GB limit |
| 인덱스 수 | 4 |
| 샤드 수 | 4 per index (총 16) |
| Replica | 0 |
| 쿼리 캐시 | 비활성 (`request_cache=false`) |

**Forcemerge 조건:**
각 선택지를 NoFM (인덱싱 직후 상태)과 FM (forcemerge `max_num_segments=1` 적용) 두 가지로 측정한다.
- **NoFM**: 운영 중 자연스러운 세그먼트 상태 (실 운영과 유사)
- **FM**: 세그먼트 최적화 완료 상태 (이론적 최적치)

---

## 쿼리 조건

동일한 필터 요청을 각 구조에 보낸다.
단, 구조가 다르므로 **ES 쿼리 문법은 다르다**:

| | 선택지 A (LBT) | 선택지 B (L) |
|---|---|---|
| 토지 필터 | `land.area >= 100` (root-level) | `land.area >= 100` (root-level) — **동일** |
| 건물 필터 | `nested(path=buildings) { buildings.mainPurpsCdNm = "공장" }` | `building.mainPurpsCdNm = "공장"` (root-level) |
| 실거래 필터 | `nested(path=trades) { trades.effectiveAmount >= 1억 }` | `trade.effectiveAmount >= 1억` (root-level) |

**필터 의도는 동일하고, 쿼리 구조만 다르다.**

### 필터 카테고리별 쿼리셋 (총 500개, 각 125개)

| ID | 카테고리 | 어떤 필터가 들어오는가 | 왜 따로 측정하는가 |
|----|---------|---------------------|------------------|
| C1 | **토지만** | 지역코드, 지목, 면적, 공시지가 | 두 구조 모두 root-level 쿼리 → 구조 차이 없는 기준선 |
| C2 | **건물만** | 용도, 등록구분, 면적, 승인일 | A는 nested 필요, B는 root-level → nested 비용 단독 측정 |
| C3 | **실거래만** | 유형, 계약일, 거래금액, 단가 | A는 nested 필요, B는 root-level → nested 비용 단독 측정 |
| C4 | **복합** | 토지 + 건물 + 실거래 전부 | A는 nested 2개 + root, B는 root만 → 누적 비용 측정 |

---

## 테스트 방법

### 공통 조건

- **독립 측정**: 한 번에 하나의 ES 인스턴스만 실행. CPU/메모리를 독점하여 다른 인스턴스의 영향을 배제
- **쿼리 캐시 비활성**: 모든 요청에 `request_cache=false`. 매번 새로 계산
- **쿼리 범위**: 전국구 바운딩박스, 시도(sd) 단위 집계
- **쿼리 형태**: `size: 0` (문서 본문 반환 없음, 집계만 수행)
- **쿼리셋**: 500개 (토지 125 + 건물 125 + 실거래 125 + 복합 125), seed=42 고정, 셔플 상태
- **대기 시간 없음**: 쿼리 간 인위적인 간격 없이 응답 받는 즉시 다음 쿼리 발사
- **이상치 제거**: IQR × 1.5 기준으로 극단값 제외 후 통계 산출
- **실행 순서**: LBT nofm → L nofm → LBT fm → L fm (매번 컨테이너 교체)

### T1: 순차 테스트 — "1명이 연속으로 쏘면?"

1명의 사용자가 500개 쿼리를 쉬지 않고 순서대로 쏜다. 이것을 여러 라운드 반복한다.

```
[웜업] 2라운드 × 500쿼리 = 1,000회 → 버림 (ES 워밍업)
[측정] 9라운드 × 500쿼리 = 4,500회 → 통계 산출
```

- 사용자 수: **1명** (단일 스레드)
- 쿼리 간격: **0초** (응답 오면 즉시 다음 쿼리)
- 측정 지표: 쿼리당 ES 처리 시간 (took ms)
- 카테고리별 별도 집계 (토지/건물/실거래/복합)

### T2: 부하 테스트 — "N명이 동시에 쏘면?"

N명의 사용자가 동시에 30초간 쿼리를 쉬지 않고 쏜다. 각 사용자는 응답이 오면 바로 다음 쿼리를 보낸다.

```
[5명]  30초간 → RPS, p50, p95 기록
[15명] 30초간 → RPS, p50, p95 기록
[25명] 30초간 → RPS, p50, p95 기록
```

- 사용자 수: **5명 → 15명 → 25명** (단계별 증가)
- 쿼리 간격: **0초** (각 사용자가 응답 받으면 즉시 다음 쿼리)
- 쿼리 분배: 공유 카운터로 500개 쿼리를 순환 (모든 사용자가 고르게 소비)
- 측정 지표: RPS (초당 처리량), ES 처리 시간 p50/p95

---

## 실행 순서

매 측정마다 **컨테이너를 내리고 → 다른 볼륨으로 올리고 → 벤치마크 → 내림**을 반복한다.
동시에 두 개의 ES가 뜨는 일은 없다.

```
1. LBT nofm 볼륨으로 컨테이너 기동 → T1+T2 벤치마크 → 컨테이너 종료
2. L nofm 볼륨으로 컨테이너 기동 → T1+T2 벤치마크 → 컨테이너 종료
3. LBT fm 볼륨으로 컨테이너 기동 → T1+T2 벤치마크 → 컨테이너 종료
4. L fm 볼륨으로 컨테이너 기동 → T1+T2 벤치마크 → 컨테이너 종료
```

모든 컨테이너는 동일한 리소스(CPU 3코어, 메모리 8g, 힙 4g)로 기동한다.

---

## 결과

### 인덱스 기본 정보

| 항목 | 선택지 A (LBT) | 선택지 B (L) |
|------|---------------|-------------|
| Lucene docs | ~87.7M | ~39.7M |
| 디스크 용량 (4인덱스 합) | ~7.9GB | ~5.6GB |
| 세그먼트/샤드 (NoFM) | 다수 | 다수 |
| 세그먼트/샤드 (FM) | 1 | 1 |

### T1 순차 테스트 — 전체 요약

> 4,500회 측정, IQR 이상치 제거

| 지표 | LBT NoFM | LBT FM | L NoFM | L FM |
|------|----------|--------|--------|------|
| **mean** | 144.51ms | 68.78ms | 67.62ms | 34.34ms |
| **p50** | 98ms | 48ms | 42ms | 14ms |
| **p90** | 299ms | 149ms | 152ms | 83ms |
| **p95** | 420ms | 210ms | 221ms | 139ms |
| **p99** | 796ms | 392ms | 413ms | 315ms |
| **RPS** | ~6.5 | ~13.0 | ~14.0 | ~27.0 |

### T1 순차 테스트 — 카테고리별 수용력

> "이 필터가 들어왔을 때, 평균 응답이 이 정도 걸린다"

**NoFM (인덱싱 직후 상태):**

| 필터 유형 | LBT avg | LBT p95 | L avg | L p95 |
|----------|---------|---------|-------|-------|
| C1: 토지만 | 210ms | 570ms | 125ms | 355ms |
| C2: 건물만 | 92ms | 283ms | 46ms | 118ms |
| C3: 실거래만 | 146ms | 389ms | 43ms | 116ms |
| C4: 복합 | 130ms | 329ms | 58ms | 153ms |

**FM (forcemerge 적용):**

| 필터 유형 | LBT avg | LBT p95 | L avg | L p95 |
|----------|---------|---------|-------|-------|
| C1: 토지만 | 124ms | 354ms | 86ms | 302ms |
| C2: 건물만 | 37ms | 101ms | 21ms | 68ms |
| C3: 실거래만 | 78ms | 173ms | 17ms | 57ms |
| C4: 복합 | 37ms | 104ms | 13ms | 40ms |

### T2 부하 테스트 — 동시 사용자별 수용력

> "동시 사용자가 이만큼일 때, 초당 처리량과 체감 응답이 이 정도다"

**선택지 A (LBT):**

| 동시 유저 | NoFM RPS | NoFM p50 | NoFM p95 | FM RPS  | FM p50  | FM p95 |
|-------|----------|----------|----------|---------|---------|--------|
| 5     | 7.72     | 528ms    | 1513ms   | 14.79   | 298ms   | 611ms |
| 15    | 8.20     | 1704ms   | 3109ms   | 13.02   | 1078ms  | 1771ms |
| 25    | 6.46     | 4118ms   | 4543ms   | 13.94   | 1693ms  | 2588ms |

**선택지 B (L):**

| 동시 유저 | NoFM RPS | NoFM p50 | NoFM p95 | FM RPS | FM p50 | FM p95 |
|----------|----------|----------|----------|--------|--------|--------|
| 5 | 9.82 | 489ms | 896ms | 28.82 | 134ms | 396ms |
| 15 | 13.65 | 1000ms | 1877ms | 27.25 | 511ms | 873ms |
| 25 | 10.75 | 2065ms | 3694ms | 27.32 | 862ms | 1381ms |

---

## 결론

### 선택지 A (LBT) — 이런 구조입니다

- **C1 (토지 필터)**: 두 구조 모두 root-level 쿼리이지만, LBT는 Lucene doc 수 자체가 87M으로 L 대비 2.2배. NoFM 기준 210ms, FM 기준 124ms
- **C2 (건물 필터)**: nested 쿼리 비용 발생. NoFM 기준 92ms (L의 46ms 대비 2x)
- **C3 (실거래 필터)**: nested 비용이 가장 크게 드러남. NoFM 기준 146ms (L의 43ms 대비 3.4x). 실거래 배열이 가장 크기 때문
- **C4 (복합 필터)**: nested 2개 + root-level 조합. NoFM 130ms (L의 58ms 대비 2.2x)
- **부하 시**: NoFM 25유저에서 RPS 6.46으로 급락, p95가 4.5초까지 치솟음. FM 적용 시 13.94 RPS로 2배 이상 개선되나, L FM (27.32)의 절반 수준
- **Forcemerge 효과**: 순차 평균 144ms → 69ms (2.1x 개선). 특히 복합 필터가 130ms → 37ms (3.5x)로 가장 큰 개선
- **향후 전망**: 실거래 데이터가 매년 쌓이므로 Lucene docs 지속 증가 → 위 수치는 점차 악화

### 선택지 B (L) — 이런 구조입니다

- **C1 (토지 필터)**: root-level 쿼리. NoFM 125ms, FM 86ms. LBT와 동일한 토지 데이터지만 Lucene doc 수가 절반 이하라 더 빠름
- **C2 (건물 필터)**: root-level object 필터. NoFM 46ms, FM 21ms
- **C3 (실거래 필터)**: root-level object 필터. NoFM 43ms, FM 17ms. nested가 없어 건물과 비슷한 수준
- **C4 (복합 필터)**: 모든 필터가 root-level. NoFM 58ms, FM 13ms. 가장 빠른 카테고리
- **부하 시**: FM 기준 25유저에서도 RPS 27.32 유지, p95 1381ms. LBT FM 대비 2배 높은 처리량
- **Forcemerge 효과**: 순차 평균 68ms → 34ms (2x 개선). 부하 RPS도 10.75 → 27.32 (2.5x)
- **향후 전망**: Lucene docs ~39M 고정, 성능 변동 거의 없음

### 종합

1. **구조 차이**: LBT의 nested 배열이 Lucene doc 수를 87M으로 부풀림 (L은 39M). 이 차이가 모든 지표에 반영됨
2. **nested 비용**: 특히 실거래 필터에서 극명 — LBT NoFM 146ms vs L NoFM 43ms (3.4x 차이)
3. **Forcemerge 효과**: 두 구조 모두 약 2x 개선. 하지만 **LBT FM (69ms)이 L NoFM (68ms)과 비슷한 수준**. 즉, LBT는 forcemerge를 해야 L의 기본 상태를 따라잡음
4. **부하 수용력**: L FM은 25유저에서도 27 RPS를 유지. LBT FM은 14 RPS. LBT NoFM은 6.5 RPS로 급락
5. **시간에 따른 변화**: LBT는 실거래 누적으로 Lucene docs가 계속 증가하여 성능이 점진 악화. L은 고정

---

## 관련 파일

| 파일 | 역할 |
|------|------|
| `benchmark/l_vs_lbt_queryset_generator.py` | 쿼리셋 생성기 (4카테고리 × 125) |
| `benchmark/l_vs_lbt_queryset_500.json` | 쿼리셋 (seed=42, 재현 가능) |
| `benchmark/l_vs_lbt_independent.py` | 독립 벤치마크 스크립트 (T1+T2 통합) |
| `benchmark/results/lbt_nofm_independent.json` | LBT NoFM 결과 |
| `benchmark/results/l_nofm_independent.json` | L NoFM 결과 |
| `benchmark/results/lbt_fm_independent.json` | LBT FM 결과 |
| `benchmark/results/l_fm_independent.json` | L FM 결과 |
