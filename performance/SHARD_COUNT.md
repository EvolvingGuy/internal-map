# 벤치마크 03: 샤드 수 비교

---

## 목적
- 샤드 수가 쿼리 성능에 미치는 영향 측정
- 싱글노드 환경에서 최적 샤드 수 경향성 파악

---

## 배경

샤드 수의 트레이드오프:
- **샤드 증가 장점**: 병렬 처리, 인덱싱 분산
- **샤드 증가 단점**: 오버헤드 증가, 메모리 사용량 증가, 코디네이션 비용

싱글노드에서는:
- 병렬 처리 이점이 제한적
- 오버헤드가 상대적으로 더 부각될 수 있음

---

## 전제 조건

- [ ] 동일한 데이터셋
- [ ] 샤드 수만 다른 인덱스 N개 생성
- [ ] 레플리카는 0으로 통일 (싱글노드)
- [ ] forcemerge 상태 동일

---

## 테스트 설계

### 옵션 A: 기존 인덱스 복제
- 기존 LC 또는 LNBT 데이터를 reindex
- 샤드 수만 다르게 설정
- 장점: 실제 데이터 규모
- 단점: 시간 소요, 디스크 사용량

### 옵션 B: 샘플 데이터셋
- 일부 데이터만 추출 (예: 특정 시도)
- 여러 샤드 설정으로 인덱싱
- 장점: 빠른 테스트
- 단점: 규모 효과 제한적

(어떤 방식으로 할지 결정 필요)

---

## 테스트 샤드 수

| 샤드 수 | 설명 |
|---------|------|
| 1 | 최소, 오버헤드 없음 |
| 3 | ES 기본값 (구버전) |
| 5 | 중간 |
| 10 | 과다 (오버헤드 확인용) |

(전부 할지, 일부만 할지 결정 필요)

---

## 측정 항목

### 1. 쿼리 성능
- 단순 필터 쿼리 latency
- 집계 쿼리 latency
- 샤드별 처리 시간 분포

### 2. 리소스 사용
- 인덱스 용량 (샤드 메타데이터 오버헤드)
- 쿼리 시 메모리 사용 (가능하다면)

---

## 인덱스 생성 설정 예시

```json
{
  "settings": {
    "number_of_shards": N,
    "number_of_replicas": 0,
    "refresh_interval": "30s"
  }
}
```

---

## 변수 통제

| 항목 | 통제 방법 |
|------|----------|
| 데이터 | 완전 동일한 문서 |
| 매핑 | 동일한 매핑 |
| forcemerge | 모든 인덱스 동일하게 적용 |
| 쿼리 캐시 | request_cache=false |

---

## 미결정 사항

1. 옵션 A vs B (전체 데이터 vs 샘플)
2. 테스트할 샤드 수 목록
3. 데이터 소스 인덱스 (LC? LNBT?)
4. 디스크 공간 확보 가능 여부

---

## 예상 결과 가설

- 싱글노드에서는 샤드 1~3이 최적일 것
- 샤드 수 과다 시 오버헤드로 성능 저하
- 쿼리 유형에 따라 최적 샤드 수 다를 수 있음

---

## 클러스터 적용 시 주의

이 테스트 결과는 **싱글노드 기준**
- 클러스터에서는 노드 수, 데이터 크기에 따라 최적값 다름
- 경향성(샤드 과다 = 오버헤드)은 유효
- 절대적 최적값은 환경별로 재측정 필요

---

## 실행 전 체크리스트

- [ ] 디스크 공간 확인
- [ ] 데이터 소스 및 범위 결정
- [ ] 테스트 인덱스 명명 규칙 (예: lc_shard_1, lc_shard_3, ...)
- [ ] 인덱스 생성 스크립트 준비
